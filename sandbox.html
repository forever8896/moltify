<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Moltify Sandbox</title>
  <script src="https://unpkg.com/tone@14.7.77/build/Tone.js"></script>
</head>
<body>
<script>
// Moltify Audio Sandbox v2
// Simpler approach: just block dangerous APIs at runtime

// Track state
let isPlaying = false;
let executionTimeout = null;

// Block dangerous globals by overwriting them
const BLOCKED_APIS = [
  'fetch', 'XMLHttpRequest', 'WebSocket', 'EventSource',
  'localStorage', 'sessionStorage', 'indexedDB', 'caches',
  'Notification', 'PushManager', 'BroadcastChannel',
  'RTCPeerConnection', 'RTCDataChannel',
  'Worker', 'SharedWorker'
];

// Save reference to postMessage before potential tampering
const safePostMessage = parent.postMessage.bind(parent);

// Neuter dangerous APIs
for (const api of BLOCKED_APIS) {
  try {
    window[api] = undefined;
  } catch(e) {}
}

// Make document mostly inert (but keep what Tone.js needs)
const originalDocument = document;
document.cookie = '';
document.write = () => {};
document.writeln = () => {};

// Block navigation
window.location.assign = () => {};
window.location.replace = () => {};
window.open = () => null;

// Execute track code
async function executeTrack(code, duration) {
  await stopPlayback();
  
  try {
    await Tone.start();
    console.log('[Sandbox] Starting playback');
    
    isPlaying = true;
    
    // Hard timeout
    const maxDuration = (duration + 5) * 1000;
    executionTimeout = setTimeout(() => {
      console.warn('[Sandbox] Timeout reached');
      stopPlayback();
    }, maxDuration);
    
    // Execute the code directly
    // The code runs in this iframe's context which has:
    // - Tone.js available
    // - Dangerous APIs blocked
    // - No access to parent DOM
    eval(code);
    
    safePostMessage({ type: 'playing', duration }, '*');
    
  } catch (error) {
    console.error('[Sandbox] Error:', error);
    safePostMessage({ type: 'error', message: error.message }, '*');
    stopPlayback();
  }
}

// Stop playback
async function stopPlayback() {
  isPlaying = false;
  
  if (executionTimeout) {
    clearTimeout(executionTimeout);
    executionTimeout = null;
  }
  
  try {
    Tone.Transport.stop();
    Tone.Transport.cancel();
    Tone.Transport.position = 0;
    
    // Mute then unmute to clear any lingering sounds
    const dest = Tone.getDestination();
    dest.volume.value = -Infinity;
    await new Promise(r => setTimeout(r, 50));
    dest.volume.value = 0;
  } catch(e) {
    console.warn('[Sandbox] Cleanup error:', e);
  }
  
  safePostMessage({ type: 'stopped' }, '*');
}

// Listen for messages
window.addEventListener('message', async (event) => {
  const { type, code, duration } = event.data;
  
  if (type === 'play' && code && duration) {
    await executeTrack(code, duration);
  } else if (type === 'stop') {
    await stopPlayback();
  } else if (type === 'ping') {
    safePostMessage({ type: 'pong' }, '*');
  }
});

// Signal ready
safePostMessage({ type: 'ready' }, '*');
console.log('[Sandbox] Audio sandbox v2 ready');
</script>
</body>
</html>
